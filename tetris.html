<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pastel Puzzle</title>
    <style>
        :root {
            /* Pastel Palette */
            --bg-color: #fdf0f2;
            --text-color: #6d6d6d;
            --shadow-color: rgba(0, 0, 0, 0.08);

            /* Piece Colors */
            --c-1: #A2D2FF;
            /* Blue */
            --c-2: #FFC8DD;
            /* Pink */
            --c-3: #CDB4DB;
            /* Lavender */
            --c-4: #FFAFCC;
            /* Hot Pink */
            --c-5: #BDE0FE;
            /* Light Blue */
            --c-6: #FFD6A5;
            /* Peach */
            --c-7: #CAFFBF;
            /* Green */
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            justify-content: space-evenly;
        }

        /* HEADER */
        .header {
            text-align: center;
            width: 100%;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #555;
            letter-spacing: 1px;
        }

        .scores-container {
            display: flex;
            gap: 20px;
            margin-top: 5px;
        }

        .score-box {
            background: white;
            padding: 8px 15px;
            border-radius: 15px;
            box-shadow: 0 4px 10px var(--shadow-color);
            text-align: center;
            min-width: 100px;
        }

        .score-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: #aaa;
            letter-spacing: 1px;
        }

        .score-val {
            font-size: 1.3rem;
            font-weight: 800;
            color: var(--c-3);
        }

        /* GAME GRID CONTAINER */
        #game-container {
            position: relative;
            background: white;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 5px 20px var(--shadow-color);
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas#grid {
            display: block;
            border-radius: 8px;
            width: 100%;
            height: 100%;
        }

        /* TRAY */
        .tray {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            gap: 5%;
            padding: 10px 0;
            flex-shrink: 0;
            min-height: 120px;
        }

        .tray-slot {
            width: 25vw;
            height: 25vw;
            max-width: 100px;
            max-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tray-piece {
            transition: transform 0.1s;
            pointer-events: auto;
        }

        .tray-piece.dragging-source {
            opacity: 0.3;
        }

        /* DRAG HELPER */
        #drag-helper {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 9999;
            display: none;
            filter: drop-shadow(0 15px 25px rgba(0, 0, 0, 0.3));
            opacity: 0.95;
            touch-action: none;
        }

        /* BUTTONS */
        .btn-restart {
            margin-top: 5px;
            background: transparent;
            border: none;
            color: #888;
            padding: 8px 16px;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            text-decoration: underline;
        }

        /* GAME OVER */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            z-index: 100;
        }

        #game-over h2 {
            font-size: 2rem;
            color: var(--c-4);
            margin-bottom: 0.5rem;
        }

        .btn-primary {
            background: var(--c-7);
            color: #555;
            padding: 12px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div class="header">
        <h1>B L O C K S</h1>
        <div class="scores-container">
            <div class="score-box">
                <div class="score-label">Score</div>
                <div class="score-val" id="score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Best</div>
                <div class="score-val" id="best-score">0</div>
            </div>
        </div>
        <button class="btn-restart" onclick="restartGame()">Restart Game</button>
    </div>

    <div id="game-container">
        <canvas id="grid"></canvas>

        <div id="game-over">
            <h2>No Moves!</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button class="btn-primary" onclick="restartGame()">Try Again</button>
        </div>
    </div>

    <div class="tray">
        <div class="tray-slot" id="slot-0"></div>
        <div class="tray-slot" id="slot-1"></div>
        <div class="tray-slot" id="slot-2"></div>
    </div>

    <canvas id="drag-helper"></canvas>

    <script>
        // --- CONSTANTS ---
        const GRID_ROWS = 10;
        const GRID_COLS = 10;
        const PALETTE = ['#A2D2FF', '#FFC8DD', '#CDB4DB', '#FFAFCC', '#BDE0FE', '#FFD6A5', '#CAFFBF'];

        const SHAPES = [
            [[1]],
            [[1, 1], [1, 1]],
            [[1], [1]],
            [[1, 1]],
            [[1], [1], [1]],
            [[1, 1, 1]],
            [[1], [1], [1], [1]],
            [[1, 1, 1, 1]],
            [[1, 1], [1, 0]],
            [[1, 1], [0, 1]],
            [[1, 0], [1, 1]],
            [[0, 1], [1, 1]],
            [[1, 0, 0], [1, 1, 1]],
            [[1, 1, 1], [0, 0, 1]],
            [[1, 1, 1], [0, 1, 0]],
            [[0, 1, 0], [1, 1, 1]],
            [[1, 0], [1, 1], [1, 0]],
            [[0, 1], [1, 1], [0, 1]]
        ];

        // --- STATE ---
        let grid = [];
        let score = 0;
        let bestScore = localStorage.getItem('blockPuzzleBestScore') || 0;
        let trayPieces = [null, null, null];

        // Dragging State
        let isDragging = false;
        let dragPieceData = null;
        let dragOffset = { x: 0, y: 0 };

        // DOM
        const gridCanvas = document.getElementById('grid');
        const gridCtx = gridCanvas.getContext('2d');
        const dragCanvas = document.getElementById('drag-helper');
        const dragCtx = dragCanvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('best-score');

        let cellSize = 0;
        let gridRect = null;

        // --- INIT ---
        function init() {
            window.addEventListener('resize', handleResize);

            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
            document.addEventListener('touchmove', onDragMove, { passive: false });
            document.addEventListener('touchend', onDragEnd);

            // Display initial best score
            bestScoreEl.innerText = bestScore;

            restartGame();
            handleResize();
        }

        // --- RESIZING ---
        function handleResize() {
            const containerW = gameContainer.clientWidth;
            const containerH = gameContainer.clientHeight;
            const dpr = window.devicePixelRatio || 1;

            gridCanvas.width = containerW * dpr;
            gridCanvas.height = containerH * dpr;

            gridCtx.setTransform(1, 0, 0, 1, 0, 0);
            gridCtx.scale(dpr, dpr);

            cellSize = containerW / GRID_COLS;

            drawGrid();
            gridRect = gridCanvas.getBoundingClientRect();
        }

        // --- GAME LOGIC ---
        function restartGame() {
            // Updated: Ensure grid is visually cleared immediately
            grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(0));
            score = 0;
            updateScoreUI();

            document.getElementById('game-over').style.display = 'none';

            refillTray();
            drawGrid(); // FIXED: Explicit redraw to clear visuals
        }

        function refillTray() {
            trayPieces = [getRandomPiece(), getRandomPiece(), getRandomPiece()];
            renderTray();

            // Allow render to happen before checking game over (rare edge case on restart)
            setTimeout(checkGameOver, 100);
        }

        function getRandomPiece() {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
            return { shape, color, id: Math.random() };
        }

        function renderTray() {
            trayPieces.forEach((piece, index) => {
                const slot = document.getElementById(`slot-${index}`);
                slot.innerHTML = '';

                if (piece) {
                    const canvas = document.createElement('canvas');
                    canvas.className = 'tray-piece';
                    canvas.dataset.index = index;

                    const previewCellSize = 25;
                    const pRows = piece.shape.length;
                    const pCols = piece.shape[0].length;

                    canvas.width = pCols * previewCellSize;
                    canvas.height = pRows * previewCellSize;

                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = piece.color;
                    for (let r = 0; r < pRows; r++) {
                        for (let c = 0; c < pCols; c++) {
                            if (piece.shape[r][c]) {
                                roundedRect(ctx, c * previewCellSize, r * previewCellSize, previewCellSize - 2, previewCellSize - 2, 4);
                            }
                        }
                    }

                    canvas.addEventListener('mousedown', (e) => onDragStart(e, index));
                    canvas.addEventListener('touchstart', (e) => onDragStart(e, index), { passive: false });

                    slot.appendChild(canvas);
                }
            });
        }

        // --- INPUT HANDLING ---
        function onDragStart(e, index) {
            e.preventDefault();
            if (document.getElementById('game-over').style.display === 'flex') return;

            const piece = trayPieces[index];
            if (!piece) return;

            isDragging = true;
            dragPieceData = { ...piece, slotIndex: index };

            e.target.classList.add('dragging-source');

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = e.target.getBoundingClientRect();

            const ratioX = (clientX - rect.left) / rect.width;
            const ratioY = (clientY - rect.top) / rect.height;

            const pRows = piece.shape.length;
            const pCols = piece.shape[0].length;
            const helperWidth = pCols * cellSize;
            const helperHeight = pRows * cellSize;

            dragCanvas.width = helperWidth;
            dragCanvas.height = helperHeight;
            dragCanvas.style.width = helperWidth + 'px';
            dragCanvas.style.height = helperHeight + 'px';

            dragOffset.x = helperWidth * ratioX;
            dragOffset.y = helperHeight * ratioY;

            const VISUAL_LIFT = 80; // Increased lift for visibility
            dragOffset.y += VISUAL_LIFT;

            dragCtx.clearRect(0, 0, dragCanvas.width, dragCanvas.height);
            dragCtx.fillStyle = piece.color;
            for (let r = 0; r < pRows; r++) {
                for (let c = 0; c < pCols; c++) {
                    if (piece.shape[r][c]) {
                        roundedRect(dragCtx, c * cellSize, r * cellSize, cellSize - 2, cellSize - 2, 6);
                    }
                }
            }

            dragCanvas.style.display = 'block';
            updateDragPosition(clientX, clientY);
        }

        function onDragMove(e) {
            if (!isDragging) return;
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            updateDragPosition(clientX, clientY);

            const gridPos = getGridPosition(clientX, clientY);
            drawGrid(gridPos);
        }

        function onDragEnd(e) {
            if (!isDragging) return;

            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

            const gridPos = getGridPosition(clientX, clientY);

            let placed = false;

            if (gridPos) {
                if (canPlace(dragPieceData.shape, gridPos.r, gridPos.c)) {
                    placePiece(dragPieceData, gridPos.r, gridPos.c);

                    trayPieces[dragPieceData.slotIndex] = null;
                    renderTray();

                    checkLines();
                    checkLayoutState();

                    placed = true;
                }
            }

            isDragging = false;
            dragCanvas.style.display = 'none';
            dragPieceData = null;

            if (!placed) {
                renderTray();
            }

            drawGrid();
        }

        function updateDragPosition(cx, cy) {
            const x = cx - dragOffset.x;
            const y = cy - dragOffset.y;
            dragCanvas.style.transform = `translate(${x}px, ${y}px)`;
        }

        function getGridPosition(cx, cy) {
            const helperX = cx - dragOffset.x;
            const helperY = cy - dragOffset.y;

            gridRect = gridCanvas.getBoundingClientRect();

            const relX = helperX - gridRect.left;
            const relY = helperY - gridRect.top;

            const colF = relX / cellSize;
            const rowF = relY / cellSize;

            const c = Math.round(colF);
            const r = Math.round(rowF);

            return { r, c };
        }

        // --- GRID LOGIC ---
        function canPlace(shape, r, c) {
            const rows = shape.length;
            const cols = shape[0].length;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (shape[i][j] === 1) {
                        const targetR = r + i;
                        const targetC = c + j;
                        if (targetR < 0 || targetR >= GRID_ROWS || targetC < 0 || targetC >= GRID_COLS) return false;
                        if (grid[targetR][targetC] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function placePiece(piece, r, c) {
            const shape = piece.shape;
            for (let i = 0; i < shape.length; i++) {
                for (let j = 0; j < shape[0].length; j++) {
                    if (shape[i][j]) {
                        grid[r + i][c + j] = piece.color;
                    }
                }
            }

            // Scoring
            const blockCount = shape.flat().reduce((a, b) => a + b, 0);
            score += blockCount;
            updateScoreUI();
        }

        function checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for (let r = 0; r < GRID_ROWS; r++) {
                if (grid[r].every(val => val !== 0)) rowsToClear.push(r);
            }
            for (let c = 0; c < GRID_COLS; c++) {
                let full = true;
                for (let r = 0; r < GRID_ROWS; r++) {
                    if (grid[r][c] === 0) { full = false; break; }
                }
                if (full) colsToClear.push(c);
            }

            if (rowsToClear.length === 0 && colsToClear.length === 0) return;

            rowsToClear.forEach(r => {
                for (let c = 0; c < GRID_COLS; c++) grid[r][c] = 0;
            });
            colsToClear.forEach(c => {
                for (let r = 0; r < GRID_ROWS; r++) grid[r][c] = 0;
            });

            const total = rowsToClear.length + colsToClear.length;
            score += total * 10 + (total > 1 ? (total * 5) : 0);
            updateScoreUI();
        }

        function checkLayoutState() {
            if (trayPieces.every(p => p === null)) {
                setTimeout(refillTray, 200);
            } else {
                checkGameOver();
            }
        }

        function checkGameOver() {
            const tempPieces = trayPieces.filter(p => p !== null);
            if (tempPieces.length === 0) return;

            let possibleMove = false;
            for (let p of tempPieces) {
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (canPlace(p.shape, r, c)) {
                            possibleMove = true;
                            break;
                        }
                    }
                    if (possibleMove) break;
                }
                if (possibleMove) break;
            }

            if (!possibleMove) {
                document.getElementById('final-score').innerText = score;
                document.getElementById('game-over').style.display = 'flex';
            }
        }

        // --- DRAWING ---
        function drawGrid(ghostPos = null) {
            gridCtx.save();
            gridCtx.setTransform(1, 0, 0, 1, 0, 0);
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            gridCtx.restore();

            // Background
            gridCtx.fillStyle = '#fceef0';
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const gap = 2;
                    roundedRect(gridCtx, c * cellSize + gap / 2, r * cellSize + gap / 2, cellSize - gap, cellSize - gap, 4);
                }
            }

            // Pieces
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c] !== 0) {
                        gridCtx.fillStyle = grid[r][c];
                        roundedRect(gridCtx, c * cellSize + 1, r * cellSize + 1, cellSize - 2, cellSize - 2, 5);
                    }
                }
            }

            // Ghost
            if (ghostPos && dragPieceData) {
                const { r, c } = ghostPos;
                const valid = canPlace(dragPieceData.shape, r, c);

                if (valid) {
                    gridCtx.globalAlpha = 0.4;
                    gridCtx.fillStyle = dragPieceData.color;

                    const shape = dragPieceData.shape;
                    for (let i = 0; i < shape.length; i++) {
                        for (let j = 0; j < shape[0].length; j++) {
                            if (shape[i][j]) {
                                roundedRect(gridCtx, (c + j) * cellSize + 1, (r + i) * cellSize + 1, cellSize - 2, cellSize - 2, 5);
                            }
                        }
                    }
                    gridCtx.globalAlpha = 1.0;
                }
            }
        }

        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function updateScoreUI() {
            scoreEl.innerText = score;
            if (score > bestScore) {
                bestScore = score;
                bestScoreEl.innerText = bestScore;
                localStorage.setItem('blockPuzzleBestScore', bestScore);
            }
        }

        // Start
        init();

    </script>
</body>

</html>